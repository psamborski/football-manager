import logging
import warnings
from typing import Optional
from pydantic import BaseModel, Field, ValidationError, model_validator

from app.database import get_db_session
from app.models.utils import reformat_club_data_from_db

from app.resources.ClubResource import ClubResource

from config import LOGGER


class ClubModel(BaseModel):
    """
    Represents a club entity in the app.models module, managing essential 
    attributes, validation, and database operations for a club object.

    Attributes:
        club_id (Optional[int]): The unique identifier for the club in the database.
        name (Optional[str]): Full name of the club, restricted to 100 characters.
        league_id (Optional[int]): ID of the league associated with the club.
        players_ids (Optional[list[int]]): List of player IDs associated with the club.
    """
    club_id: Optional[int] = Field(default=None, description="ID of the club in the database")
    name: Optional[str] = Field(default=None, description="Name of the club", max_length=100)
    league_id: Optional[int] = Field(default=None, description="Country object associated with the club")
    players_ids: Optional[list[int]] = Field(default=None, description="List of players associated with this club")

    @model_validator(mode="after")
    def validate_input(cls, values):
        """
        Validates the input fields of the `ClubModel`.

        Rules for valid configurations:
        1. Only `club_id` is provided; all other fields are `None`.
        2. All fields except `club_id` are provided and not `None`.
        3. All fields are provided, including `club_id`.

        This ensures logical consistency in club data states.

        Raises:
            ValueError: If the `ClubModel` does not fit any of the allowed configurations.
        """
        entries = {**values.model_dump()}
        del entries["players_ids"]  # exclude players from validation; including them (or not including them) won't affect object integrity

        # Check if there's only club_id
        has_only_club_id = entries.get("club_id", None) is not None and all(
            value is None for key, value in entries.items() if key != "club_id"
        )

        # Check if there are all fields but club_id
        has_all_but_club_id = entries.get("club_id", None) is None and all(
            value is not None for key, value in entries.items() if key != "club_id"
        )

        # Check if there are all fields
        has_all_fields = all(
            value is not None for key, value in entries.items()
        )

        if not (has_only_club_id or has_all_but_club_id or has_all_fields):
            raise ValueError(
                "Invalid club data. You should:\n"
                "1. Pass 'club_id' only.\n"
                "2. Pass all other fields except 'club_id'.\n"
                "3. All fields at once.\n"
                f"Given fields: {entries}\n"
                "Possible fields: club_id (int), name (str), league_id (int), players_ids (list[int]) [always optional]."
            )
        return values

    def fetch_data_by_id(self) -> "ClubModel":
        """
        Fetches a club's details using the `club_id` key.

        Retrieves data from the database, reformats it, and updates the 
        current `ClubModel` instance with valid values.

        Raises:
            ValueError: If no club record is found for the given `club_id`.
            ValidationError: If the fetched data does not pass validation.
        """
        with get_db_session() as db_session:
            club_resource = ClubResource(db_session)
            club = club_resource.get_club_by_id(self.club_id)

            if not club:
                raise ValueError(f"Club with ID {self.club_id} does not exist.")

            club_data = reformat_club_data_from_db(club)

            if self.model_validate(club_data):
                self.__dict__.update(club_data)
                return self
            else:
                raise ValidationError("Club data is invalid.")

    def create_club(self):
        """
        Creates a new club entry in the database using this instance's data 
        and assigns newly generated data to the current instance.

        Notes:
            - `club_id` is auto-generated by the database when creating a new club.
            - This method doesn't update players' club affiliations; it must be done manually.

        Raises:
            ValueError: If required fields for club creation are incomplete.
            ValidationError: If the database-generated club data fails validation.
        """

        club_data = self.model_dump(exclude={"club_id", "players_ids"})

        LOGGER.warning("Club ID will be generated automatically in the database.")
        LOGGER.warning("Creating a club won't update players' club affiliations. Please update them manually.")
        print(warnings.warn("Club ID will be generated automatically in the database."))
        print(warnings.warn("Creating a club won't update players' club affiliations. Please update them manually."))

        with get_db_session() as db_session:
            club_resource = ClubResource(db_session)
            try:
                new_club = club_resource.create_club(club_data)
            except Exception as e:
                raise ValueError("Failed to create country.")

            if new_club:
                club_data = reformat_club_data_from_db(new_club)
                if self.model_validate(club_data):
                    self.__dict__.update(club_data)
                    return self
                else:
                    raise ValidationError("Club data is invalid.")
            else:
                raise ValueError("Failed to create club.")

    def __str__(self):
        """
        Returns a string representation of the club's information, 
        showcasing key attributes in a readable format.
        """
        return (
            f"CLUB ID {self.club_id}\n"
            f"Name: {self.name}\n"
            f"League ID: {self.league_id}\n"
            f"Players' IDs: {self.players_ids or '-'}\n"
        )
