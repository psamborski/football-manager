import logging
import warnings
from typing import Optional
from pydantic import BaseModel, Field, ValidationError, model_validator

from app.database import get_db_session
from app.models.utils import reformat_league_data_from_db

from app.resources.LeagueResource import LeagueResource


class LeagueModel(BaseModel):
    """
    Represents a league entity in the app.models module, managing essential 
    attributes, validation, and database operations for a league object.

    Attributes:
        league_id (Optional[int]): The unique identifier for the league in the database.
        name (Optional[str]): Full name of the league, restricted to 100 characters.
        league_id (Optional[int]): ID of the league associated with the league.
        clubs_ids (Optional[list[int]]): List of club IDs associated with the league.
    """
    league_id: Optional[int] = Field(default=None, description="ID of the league in the database")
    name: Optional[str] = Field(default=None, description="Name of the league", max_length=100)
    clubs_ids: Optional[list[int]] = Field(default=None, description="List of clubs associated with this league")

    @model_validator(mode="after")
    def validate_input(cls, values):
        """
        Validates the input fields of the `LeagueModel`.

        Rules for valid configurations:
        1. Only `league_id` is provided; all other fields are `None`.
        2. All fields except `league_id` are provided and not `None`.
        3. All fields are provided, including `league_id`.

        This ensures logical consistency in league data states.

        Raises:
            ValueError: If the `LeagueModel` does not fit any of the allowed configurations.
        """
        entries = {**values.model_dump()}
        del entries["clubs_ids"]  # exclude clubs from validation; including them (or not including them) won't affect object integrity

        # Check if there's only league_id
        has_only_league_id = entries.get("league_id", None) is not None and all(
            value is None for key, value in entries.items() if key != "league_id"
        )

        # Check if there are all fields but league_id
        has_all_but_league_id = entries.get("league_id", None) is None and all(
            value is not None for key, value in entries.items() if key != "league_id"
        )

        # Check if there are all fields
        has_all_fields = all(
            value is not None for key, value in entries.items()
        )

        if not (has_only_league_id or has_all_but_league_id or has_all_fields):
            raise ValueError(
                "Invalid league data. You should:\n"
                "1. Pass 'league_id' only.\n"
                "2. Pass all other fields except 'league_id'.\n"
                "3. All fields at once.\n"
                "Possible fields: league_id (int), name (str), league_id (int), clubs_ids (list[int]) [always optional]."
            )
        return values

    def fetch_data_by_id(self) -> "LeagueModel":
        """
        Fetches a league's details using the `league_id` key.

        Retrieves data from the database, reformats it, and updates the 
        current `LeagueModel` instance with valid values.

        Raises:
            ValueError: If no league record is found for the given `league_id`.
            ValidationError: If the fetched data does not pass validation.
        """
        with get_db_session() as db_session:
            league_resource = LeagueResource(db_session)
            league = league_resource.get_league_by_id(self.league_id)

            if not league:
                raise ValueError(f"League with ID {self.league_id} does not exist.")

            league_data = reformat_league_data_from_db(league)

            if self.model_validate(league_data):
                self.__dict__.update(league_data)
                return self
            else:
                raise ValidationError("League data is invalid.")

    def create_league(self):
        """
        Creates a new league entry in the database using this instance's data 
        and assigns newly generated data to the current instance.

        Notes:
            - `league_id` is auto-generated by the database when creating a new league.
            - This method doesn't update clubs' league affiliations; it must be done manually.

        Raises:
            ValueError: If required fields for league creation are incomplete.
            ValidationError: If the database-generated league data fails validation.
        """

        league_data = self.model_dump(exclude={"league_id", "clubs_ids"})

        logger = logging.getLogger(__name__)
        logger.warning("League ID will be generated automatically in the database.")
        logger.warning("Creating a league won't update clubs' league affiliations. Please update them manually.")
        print(warnings.warn("League ID will be generated automatically in the database."))
        print(warnings.warn("Creating a league won't update clubs' league affiliations. Please update them manually."))

        with get_db_session() as db_session:
            league_resource = LeagueResource(db_session)
            new_league = league_resource.create_league(league_data)

            if new_league:
                league_data = reformat_league_data_from_db(new_league)
                if self.model_validate(league_data):
                    self.__dict__.update(league_data)
                    return self
                else:
                    raise ValidationError("League data is invalid.")
            else:
                raise ValueError("Failed to create league.")

    def __str__(self):
        """
        Returns a string representation of the league's information, 
        showcasing key attributes in a readable format.
        """
        return (
            f"LEAGUE ID {self.league_id}\n"
            f"Name: {self.name}\n"
            f"Clubs' IDs: {self.clubs_ids or '-'}\n"
        )
